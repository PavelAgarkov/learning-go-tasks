# learning-go-tasks

Каждая задача должна быть выполнена отдельно от остальных и иметь точку входа отдельного main.go файла.

# 1. Спроектировать и реализовать кеш в памяти сервиса

Необходимо реализовать хранение данных в памяти сервиса. Сервис - долгоживующий процесс. Необходимо реализовать http интерфейс c CRUD набором методов для работы со сущностью, которая сохраняется в хранилище памяти. Так же необходимо реализовать cli интерфейс для просмотра наполнения хранилища в памяти.

Хранилище должно иметь функционал записи в виде дампа в redis и файл. Так же при наличии ключа с данными в redis, иметь возможность воссоздать хранилище из набора данных в дампе. Если redis не доступен, сервису необходимо так же дополнительно реплицировать данные в файл и иметь возможность полностью воссоздать состояние из файла.

Необходимо придерживаться ООП для архитектуры приложения и придерживаться MVC (MVSC). Не использовать готовые фреймворки типа GIN, fiber. Предпочтительно gorilla.

Сервис должен иметь graceful shutdown. В момент завершения предусмотреть реплицирование данных из памяти в redis. Структуру для хранения можно выбрать произвольно. Сервис должен выдерживать конкурентную нагрузку.

Необходимо организовать систему логирования, которая будет писать в файл и в терминал.

Приложение целиком должно иметь возможность быть запущенным в docker-compose -f. Так же требуется реализовать docker образ для сервиса на go.(можно стянуть готовый, но нужно предусмотреть установку пакетов в образе)


# 2. Собрать свой собсвенный "фреймворк"

Собрать собсвенный скелетон проект по своим правилам. Можно это назвать свой микрофреймворк. Сделать возможность использовать http, https, grpc(s),web-socket, подключить любой механизм очередей. Главное что это все должно завершаться без ошибок и тихо по сигналу операционной системы.

Также необходимо предусмотреть механизм завершения запущенных подключений по установленному приоритету.

# 3. Сделать систему прослушивания файлового дескриптора.

Система должна реагировать на сигналы отправленные в файловый дескриптоп и выполнять логику исходя из события. 
Стоит ориентировать на api epol.

# 4. Реализовать механизм raft между сервисами

Необходимо реализовать выбор лидера между инстансами. Реализовать наблюдаемость лидером всех зарегистрированных ведомых нод.
Реализовать балансировщик перед ситстемой нод, который сможет использовать все наблюдаемые ноды. Балансировщик так же должен иметь механизм выборов лидера.

# 5. Решить проблему подписки pub/sub

Реализовать свой небольной аналог двух моделей pull and push подписки. Для этого нужен сервер и клиент.
Хранилище можно оставить в памяти сервера (наивная реализация). Система должна поддерживать консюмер группы, офсет (можно пойти в сторону топиков и партиций), балансировку при записи.

# 6. Реализовать динамический проксирующий сервер.

Сервер долженн иметь http интерфейс для регистрации и запуска новых серверов, к которым можно обращаться по урлам зафиксированным при установке прокси сервера. 

Это динамическая модель регистрации дополнительных серверов через базовый. Все добавленные серверы необходимо завершить в соответствии с приоритететом создания при сотановке базового сервиса.

# 7. Сервис коротких ссылок

Сервис принимает урл назначения и укороченный урл. При вызове укороченного сервис должен доставлять запрос на оригинальный урл.

# 8. Сделать свой механизм крона.

Не нужно брать готовые библиотеки. Распсисание может быть простым.  time.Duration.

# 9. Реализовать коллекции как в java.collections.

В go по умолчанию не так много структур данных как хотелось бы. Есть кастомные решения, но цель пройти по базовым структурам
данных и ревлизовать их в отдельном пакете.

# 10. Реализовать ограничитель запросов

Универсальный лимитер для ограничения количества запросов для пользователя. Использновать внешнее хранилище, например redis, postgres. Лимитер должен иметь распростаненные стратегии ограничения. Сервис должен иметь возможность быть распределенным, т.е. работая в многоэкземплярном режиме учитывать лимит правильно.
Стратегии ограничения:
1) количество запросов в минуту, час, день, месяц для пользователя по ip
2) количество параллельных запросов одним пользователем
3) когда общее число одновременных запросов выше определенного числа занижать лимиты для пользователей

# 11. Реализовать шаблон circuit breaker и outbox.

# 12. Реализовать сервис с добавлением на "горячую" плагины go.